---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.width = 9, 
  fig.height = 9
)
```

```{r setup}
library(hypatia)
library(ggplot2)
library(tidyverse)
```

```{r basic use}

# Create our population
pop <- squire::get_population(iso3c = "ATG")

# Scale it for speed
pop$n <- round(pop$n/10)

# Create our equivalent parameters
time_steps <- 200

 S <- individual::State$new("S", 10)
 E <- individual::State$new("E", 100)
 IMild <- individual::State$new("IMild", 0)
 human <- individual::Individual$new("human", list(S, E, IMild))

 processes <- hypatia:::create_processes(
    human$name,
    c(S$name, E$name, IMild$name)
 )

parameters <- squire::parameters_explicit_SEEIR(
  population = pop$n, 
  country = "Antigua and Barbuda", 
  contact_matrix_set = squire::get_mixing_matrix(iso3c = "ATG"),
  R0 = 2,
  time_period = time_steps,
  tt_contact_matrix = 0
  )

# run our simulation
output <- run_simulation(time_steps, pop, parameters, processes)

df <- list(output)
df <- dplyr::bind_rows(df, .id = "group")

  # Convert to long format
df <- tidyr::pivot_longer(tibble::as_tibble(df),
                              c("human_S_count", "human_E_count", 
                                "human_IMild_count"))



plot_states <- function(df) {
  ggplot(
    reshape2::melt(df, 'timestep'),
    aes(x = df$timestep, y = df$value,
    group = interaction(df$group, df$name), colour = df$name)) +
    ggplot2::geom_line(size = 0.5) +
    ggplot2::theme_bw()
}


# 
# 
#   # Create group id for data
# df <- list(output)
# df <- dplyr::bind_rows(df, .id = "group")
# 
#   # Convert to long format
# df <- tidyr::pivot_longer(tibble::as_tibble(df),
#                               c("human_S_count", "human_E_count", 
#                                 "human_IMild_count"))
# 
#   
#     strname <- "Hypatia Model Simulation"
#     subtitle <- paste(
#         "Simulation for 1 run and 1000 data points")
#   
#     time <- seq(1,200,1)
#     
#     ggplot2::ggplot(
#     df, ggplot2::aes(x = time, y = df$value,
#                      group = interaction(df$group, df$name), colour = df$name)) +
#     ggplot2::geom_line(size = 0.5) +
#     ggplot2::theme_bw() +
#     ggplot2::labs(title = strname, subtitle = subtitle) + #, color = df$legend) +
#     ggplot2::labs(y = "States", x = "time") +
#     ggplot2::theme(
#       legend.justification = c("right", "top"),
#       legend.box = c("horizontal", "vertical")) +
#     ggplot2::theme(
#       text = ggplot2::element_text(color = "#444444", family = "Lucida Bright"),
#       plot.title = ggplot2::element_text(size = 26, color = "#333333"),
#       plot.subtitle = ggplot2::element_text(size = 13),
#       axis.title.x = ggplot2::element_text(size = 16, color = "#333333"),
#       axis.title.y = ggplot2::element_text(angle = 0, vjust = .5))


```

Does it look similar to the squire output:

```{r squire}

out <- squire::run_explicit_SEEIR_model(
  population = pop$n, 
  country = "Antigua and Barbuda", 
  contact_matrix_set = squire::get_mixing_matrix(iso3c = "ATG"),
  time_period = 200, 
  replicates = 1,
  day_return = TRUE, 
  dt = 0.01
  )

plot(out)

```

Get the actual comparative outputs. 

```{r comparisons}

hyp <- tidyr::pivot_longer(output, -1) %>% 
  rename(t = timestep, compartment = name, y = value) %>% 
  mutate(compartment = gsub("(^human_)(\\w*)(_count)", "\\2", compartment),
         model = "hypatia") %>% 
  select(c("t", "compartment", "y", "model"))

sq <- squire::format_output(out, unique(hyp$compartment)) %>% 
  mutate(model = "squire") %>% 
  select(c("t", "compartment", "y", "model"))

ggplot(rbind(sq, hyp), aes(t, y, color = model)) + 
  geom_line() + 
  facet_wrap(~compartment, scales = "free")



```

## License

MIT Â© Imperial College of Science, Technology and Medicine

Really pretty close! Need to finish the correct allocation of the ages. 
`individual` appears to allocate all states in chunks, and so need to align the
ages created accordingly to get equivalent seeding
